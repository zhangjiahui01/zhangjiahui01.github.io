{"meta":{"title":"个人博客","subtitle":"","description":"随便写写","author":"Actor","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"滑动窗口的最大值","slug":"算法题/滑动窗口的最大值","date":"2020-09-11T08:23:21.247Z","updated":"2020-09-11T08:42:44.691Z","comments":true,"path":"2020/09/11/算法题/滑动窗口的最大值/","link":"","permalink":"http://example.com/2020/09/11/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/","excerpt":"","text":"问题描述（Leetcode：剑指offer 59）给定一个数组 nums 和滑动窗口的大小 k，请找出所有滑动窗口里的最大值。 输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3输出: [3,3,5,5,6,7]解释: 滑动窗口的位置 最大值 [1 3 -1] -3 5 3 6 7 3 1 [3 -1 -3] 5 3 6 7 3 1 3 [-1 -3 5] 3 6 7 5 1 3 -1 [-3 5 3] 6 7 5 1 3 -1 -3 [5 3 6] 7 6 1 3 -1 -3 5 [3 6 7] 7 思路分析 初始化： 双端队列 deque，结果列表 res，数组长度 n； 滑动窗口： 左边界范围i∈[1−k,n+1−k] ，右边界范围 j∈[0,n−1] ； ​ 若 i&gt;0且 队首元素 deque[0]= 被删除元素 nums[i−1];则队首元素出队; ​ 删除 deque内所有 &lt;nums[j]的元素，以保持 deque递减； ​ 将 nums[j]添加至 deque尾部； ​ 若已形成窗口（即 i≥0）：将窗口最大值（即队首元素 deque[0]）添加至列表 res。 返回值： 返回结果列表 res。 Java源码1234567891011121314151617181920212223242526272829import java.util.Deque;import java.util.LinkedList;class Solution &#123; public int[] maxSlidingWindow(int[] nums, int k) &#123; if (nums == null || nums.length == 0) &#123; return new int[0]; &#125; int len = nums.length; Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;(); int[] res = new int[len - k + 1]; for (int i = 0; i &lt; k; i++) &#123; while (!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i]) &#123; deque.removeLast(); &#125; deque.addLast(nums[i]); &#125; res[0] = deque.peekFirst(); for (int i = k; i &lt; len; i++) &#123; if(deque.peekFirst() == nums[i - k]) deque.removeFirst(); while(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[i]) deque.removeLast(); deque.addLast(nums[i]); res[i - k + 1] = deque.peekFirst(); &#125; return res; &#125;&#125;","categories":[],"tags":[]},{"title":"单词搜索","slug":"算法题/单词搜索","date":"2020-09-10T14:12:16.901Z","updated":"2020-09-10T14:12:17.043Z","comments":true,"path":"2020/09/10/算法题/单词搜索/","link":"","permalink":"http://example.com/2020/09/10/%E7%AE%97%E6%B3%95%E9%A2%98/%E5%8D%95%E8%AF%8D%E6%90%9C%E7%B4%A2/","excerpt":"","text":"题目描述（leetcode:79）给定一个二维网格和一个单词，找出该单词是否存在于网格中。 单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。 二维网格为 123456board =[ [&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;], [&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;], [&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;]] 思路解析(回溯算法) 构造方向数组direction：上下左右 在二维网格中找到与s.charAt(0)相等的网格作为起点，同时将此网格标志置为true 从起点出发向上下左右四个方向移动，判断与输入单词下一个字符是否相等 回溯：如果不等的话，往后退一步，检查其他三个方向，如果都不等的话，再往后退一步，直至退到能找到相等的位置，否则遍历完网格输出false 当遍历完字符串后，输出最后的结果true Java源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.Scanner;public class Main &#123; //二维网格 private static char[][] board = &#123;&#123;&#x27;A&#x27;,&#x27;B&#x27;,&#x27;C&#x27;,&#x27;E&#x27;&#125;,&#123;&#x27;S&#x27;,&#x27;F&#x27;,&#x27;C&#x27;,&#x27;S&#x27;&#125;,&#123;&#x27;A&#x27;,&#x27;D&#x27;,&#x27;E&#x27;,&#x27;E&#x27;&#125;&#125;; //方向变化 private static int[][] direction = &#123;&#123;-1, 0&#125;, &#123;0, -1&#125;, &#123;0, 1&#125;, &#123;1, 0&#125;&#125;; //网格的行 private static int m = board.length; //网格的列 private static int n = board[0].length; //标记（能走为true，不能走或未走为false） private static boolean[][] marked = new boolean[m][n]; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); String s = sc.nextLine(); System.out.println(exist(s)); &#125; private static boolean exist(String s) &#123; for (int i = 0; i &lt; m; i++) &#123; for (int j = 0; j &lt; n; j++) &#123; if (dfs(s, i, j, 0)) &#123; return true; &#125; &#125; &#125; return false; &#125; private static boolean dfs(String s, int i, int j, int start) &#123; if (start == s.length() - 1) &#123; return s.charAt(start) == board[i][j]; &#125; if (s.charAt(start) == board[i][j]) &#123; marked[i][j] = true; for (int k = 0; k &lt; 4; k++) &#123; int newX = i + direction[k][0]; int newY = j + direction[k][1]; if (inArea(newX, newY) &amp;&amp; !marked[newX][newY]) &#123; if (dfs(s, newX, newY, start + 1)) &#123; return true; &#125; &#125; &#125; &#125; return false; &#125; private static boolean inArea(int x, int y) &#123; return x &gt;= 0 &amp;&amp; x &lt; m &amp;&amp; y &gt;= 0 &amp;&amp; y &lt; n; &#125;&#125;","categories":[],"tags":[]},{"title":"楼梯问题","slug":"算法题/楼梯问题","date":"2020-09-06T01:39:29.023Z","updated":"2020-09-08T00:31:14.306Z","comments":true,"path":"2020/09/06/算法题/楼梯问题/","link":"","permalink":"http://example.com/2020/09/06/%E7%AE%97%E6%B3%95%E9%A2%98/%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98/","excerpt":"","text":"问题描述题目链接 123假设你正在爬楼梯。需要 n 阶你才能到达楼顶。每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？注意：给定 n 是一个正整数。 思路（动态规划）我们用 f(x）表示爬到第x级台阶的方案数，考虑最后一步可能跨了一级台阶，也可能跨了两级台阶，所以我们可以列出如下式子： 1f(x)&#x3D;f(x−1)+f(x−2) 它意味着爬到第x 级台阶的方案数是爬到第x-1级台阶的方案数和爬到第x-2级台阶的方案数的和。很好理解，因为每次只能爬1级或2级，所以 f(x) 只能从 f(x−1) 和 f(x−2) 转移过来，而这里要统计方案总数，我们就需要对这两项的贡献求和。 初始化我们从第0级到第0级有1种方案，即f(0)=1; 我们从第0级到第1级有1种方案，即f(1)=1; 当n&gt;1时，f(n)=f(n-1)+f(n-2)。 源码(java)1234567891011class Solution &#123; public int climbStairs(int n) &#123; int[] f=new int[n+1]; f[0]=1; f[1]=1; for(int i=2;i&lt;=n;i++)&#123; f[i]=f[i-1]+f[i-2]; &#125; return f[n]; &#125;&#125;","categories":[],"tags":[]},{"title":"Java 字符串","slug":"Java/Java 字符串","date":"2020-09-05T15:53:45.054Z","updated":"2020-09-05T17:00:16.506Z","comments":true,"path":"2020/09/05/Java/Java 字符串/","link":"","permalink":"http://example.com/2020/09/05/Java/Java%20%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"String类1. 数据转换valueOf(int/char/…)1234String str = new String();str = String.valueOf(24);char[] charArray = &#123;&#x27;a&#x27;,&#x27;c&#x27;,&#x27;t&#x27;,&#x27;o&#x27;,&#x27;r&#x27;&#125;;str = String.valueOf(charArray,offset:1,count:3);//从数组下标offset开始取count个数据 2. 字符串拼接 +3. 字符串长度 length()1int len = str.length(); 4. 查找字符串4.1 charAt(int index)方法获取字符串中指定索引位置的字符 4.2 indexOf()方法 indexOf(int ch):返回入参字符在字符串中第一次出现的索引位置 indexOf(int ch,int formIndex):从formIndex开始搜索，返回入参字符在字符串中第一次出现的索引位置 indexOf(String str):返回入参字符串在字符串中第一次出现的索引位置 indexOf(String str,int formIndex)：从formIndex开始搜索，返回入参字符串在字符串中第一次出现的索引位置 4.3 lastIndexOf()方法同indexOf()类似，返回最后一次出现的索引位置，搜索则为反向搜索。 5. 字符串替换replace()6. 字符串截取substring() substring(int beginIndex)：从入参索引位置开始截取，直到String结尾 substring(int beginIndex，int endIndex):从beginIndex到endIndex-1 7. 字符串分割split(String regex)/split(String regex,int)8. 字符串首尾判断 startsWith(String prefix):判断是否以prefix开始 startsWith(String prefix,int offset):判断从offset开始是否以prefix开始 endsWith(String suffix):判断是否以suffix结尾 9. 字符串首尾去空格trim()10. 字符串大小写转换toLowerCase()/toUpperCase11. 其他操作11.1 判断是否包含字符串 cantains(CharSequence s)11.2 转换字符数组 toCharArray()StringBuilder类与StringBuffer类1. 区别StringBuilder是非线程安全的，StringBuffer是线程安全的，但是StringBuilder比StringBuffer效率更高。 2. 创建对象12StringBuilder stringBuiler = new StringBuilder();StringBuffer stringBuffer = new StringBuffer(); 3. append(object)方法将指定内容转换成字符串，添加到StringBuilder/StringBuffer对象末端。 4. insert(int offset,object)方法在索引offset处插入指定内容。 5. delete(int start,int end)方法删除start到end-1的字符内容。 6. charAt(int)方法返回指定索引位置的字符。 7. replace(int start,int end,String str)方法8. reverse()方法将字符串序列反转，创造一个新的StringBuilder/StringBuffer对象。 1234StringBuilder stringBuiler = new StringBuilder();StringBuffer stringBuffer = new StringBuffer();stringBuiler.reverse();stringBuffer.reverse(); 9. toString()方法","categories":[],"tags":[]},{"title":"Scanner类","slug":"Java/Scanner类","date":"2020-09-05T15:42:32.206Z","updated":"2020-09-05T15:54:51.021Z","comments":true,"path":"2020/09/05/Java/Scanner类/","link":"","permalink":"http://example.com/2020/09/05/Java/Scanner%E7%B1%BB/","excerpt":"","text":"Scanner对象创建1Scanner sc = new Scanner(System.in); next()与nextLine()1 使用next方法1234567891011121314151617181920212223import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 // next方式接收字符串 System.out.println(&quot;next方式接收：&quot;); // 判断是否还有输入 if (scan.hasNext()) &#123; String str1 = scan.next(); System.out.println(&quot;输入的数据为：&quot; + str1); &#125; scan.close(); &#125;&#125;/*output:next方式接收：runoob com输入的数据为：runoob*/ 2 使用nextLine()方法1234567891011121314151617181920212223import java.util.Scanner; public class ScannerDemo &#123; public static void main(String[] args) &#123; Scanner scan = new Scanner(System.in); // 从键盘接收数据 // nextLine方式接收字符串 System.out.println(&quot;nextLine方式接收：&quot;); // 判断是否还有输入 if (scan.hasNextLine()) &#123; String str2 = scan.nextLine(); System.out.println(&quot;输入的数据为：&quot; + str2); &#125; scan.close(); &#125;&#125;/*output:nextLine方式接收：runoob com输入的数据为：runoob com*/ 3 next()与nextLine()比较 next()： 一定要读取到有效字符后才可以结束输入。 对输入有效字符之前遇到的空白（空格/换行），next() 方法会自动将其去掉。 只有输入有效字符后才将其后面输入的空白（空格/换行）作为分隔符或者结束符。 next() 不能得到带有空格的字符串。 nextLine(): 以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。 可以获得空白（空格/换行）。 先获取整数，再获取字符串1 原因：在输入数据时，当输入完int型数据后，敲击enter再输入字符串。这时，因为nextInt()只读取了int的数值却没有读取到换行符，所以，next()/nextLine()就会读取换行符返回，即空字符串。 2 解决方案一：将所有数据做为String对象获得，然后再根据需要转换数据类型 3 解决方案二：在nextInt()后再读取一个nextLine()，且不做任何处理。比如： 1234Scanner sc = new Scanner(System.in);int x = sc.nextInt();sc.nextLine();String s = sc.nextLine();","categories":[],"tags":[]},{"title":"Java 基础","slug":"Java/Java 基础","date":"2020-09-03T10:37:51.434Z","updated":"2020-09-08T01:37:22.441Z","comments":true,"path":"2020/09/03/Java/Java 基础/","link":"","permalink":"http://example.com/2020/09/03/Java/Java%20%E5%9F%BA%E7%A1%80/","excerpt":"","text":"Java 基础第一章 Java程序设计概述（简述）1.1 Java特性 简单性：剔除C++很多很少使用、难以理解、易混淆的特性；基本的解释器和类支持小，适用于嵌入式设备； 面向对象 分布式：通过URL打开和访问网络上的对象 健壮性 安全性 体系结构中立 可移植性：数据类型大小固定 解释型 高性能 多线程 动态性 第二章 Java程序设计环境（简述） 安装JDK 配置环境变量 使用Java 第三章 Java的基本程序设计结构3.1 一个简单的Java程序123456public class FirstSample&#123; public static void main(String[] args)&#123; System.out.println(&quot;Hello, World!&quot;); &#125;&#125; 访问修饰符public：控制程序的其他部分对这段代码的访问级别 关键字class：一个加载程序逻辑的容器 类名：命名规则很宽松，标准的命名规范为驼峰命名法，如FirstSample，同时也是文件名，必须保持一致。 main方法:每一个程序都会有一个main方法 {}：表示方法体的开始与结束 .：使用点号（.）调用方法，通用语法为 1object.method(parameters) 注：Java区分大小写 3.2 注释 单行注释//：从//开始到本行行末 多行注释/*……*/ 文档注释/**……*/ 3.3 数据类型 整型 int: 4字节；取值范围：-2^31——2^31-1 short:2字节；取值范围：-2^16——2^16-1 long：8字节；取值范围：-2^64——2^64-1 byte:1字节；取值范围：-2^8——2^8-1 注：长整型数值有1个后缀L或l（如：40L）；16进制数值前有1个前缀0x(如：0xCAFE)；8进制有1个前缀0 浮点型 float：4字节；有1个后缀F或f（如：3.14F） double：8字节；没有后缀，也可以加上D或d char型 字面量值用单引号括起来，如‘A’ boolean型 有两个值：true和false。用于判定逻辑条件，不可与整型相互转换。 3.4 自增与自减1234int n=5;int m=5;int a=n++;//先执行a=n，即a=5;再执行n++,即n=6int b=++m;//先执行++m,即m=6;再执行b=m,即b=6","categories":[],"tags":[]}],"categories":[],"tags":[]}